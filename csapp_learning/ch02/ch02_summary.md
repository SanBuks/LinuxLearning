# 第二章 信息的表示与处理
## 2.1 信息存储
### 十六进制表示法
- i+4j 快速转换法
- 1100 - C - 12 | 1101 - D - 13 | 1110 - E - 14

### 字数据大小 
- 字长表达指针数据大小, 指明虚拟地址空间大小
- gcc -m32/-m64 指明编译的字长
- 整型分有有符号无符号, 还有大小确定的类型如uint64_t / int64_t

| 数据类型       | 32   | 64   | minimal |
| -------------- | ---- | ---- | ------- |
| short          | 2B   | 2B   | 2B      |
| int            | 4B   | 4B   | 2B      |
| long           | 4B   | 8B   | 4B      |
| long long(cpp) | 8B   | 8B   | 8B      |
| float          | 4B   | 4B   | -       |
| double         | 8B   | 8B   | -       |

### 寻址
- 字节为最小可寻址的内存单位
- 小端法 : 从最低有效位到最高有效位 按地址从低到高排序
- 大端法 : 从最高有效位到最底有效位 按地址从低到高排序
- 强制类型转换 : `isLittleEdian()` 与`show_bytes(byte_pointer p, size_t len)`
> 注意 网络传输 和 阅读反汇编时的 大小端区别

### 字符和代码
- 字符串 以\0结尾, 每个字符用ASCII表示  0 - 48 A - 65 a - 97
- 字符串存储从前往后 按地址从底到高排序
- 代码为二进制编码与文本类型不一样


### 布尔代数
- 布尔环, , &和|的分配律
- 加法逆元, 交换方法 `inplace_swap()`
- 用途 : 掩码, 表示集合

|      | 0    | 1    |
| ---- | ---- | ---- |
| &    | 置零 | 保留 |
| \|   | 保留 | 置一 |
| ^    | 求反 | 求反 |

- bis(x, y ) == x or y |  bic(x, y) == x & ~y | x ^ y == (x & ~y) | (~x & y)

### 移位运算
- 左移补零
- 算术右移补符号位
- 逻辑右移补零
- 位移 k=k mod w

## 2.2 整数表示
### 编码
> `<climits> <cfloat>` 含有相关最大值最小值的宏

- 无符号数 : B2Uw 
- 补码 : B2Tw 不对称范围
- 反码 : B2Ow 对称双零
- 原码 : B2Sw 对称双零

### 有符号和无符号转换
- 有符号转无符号 T2Uw (负数就是加上两倍最高位权) 
- 无符号转有符号 U2Tw (超过Tmax就是减去两倍最高位权)
- 有符号数与无符号数相运算, 有符号数会优先转换成无符号数

### 扩展与截断
- 无符号扩展 加零 有符号扩展 加符号位
- 小整型运算时会先整型提升, 然后进行转换
- 无符号截断为k位 : x mod 2^k
- 有符号截断为k为 : U2T( T2U mod 2^k )

## 2.3 整数运算
### 无符号加法
- 模数加法构成阿贝尔群, 存在加法逆元
    - x+y = x+y (没溢出)
    - x+y = x+y-2^w ( 溢出 )
```c
// 无符号溢出判断
int uadd_ok(unsigned x, unsigned y){
    unsigned u=x+y;
    return u>=x;
}
```

- 无符号求反 :  -x = 2^w-x  (x != 0)

### 补码加法
- 与无符号加法有相同的位级表示
    - x+y=x+y-2^w (正溢出)
    - x+y=x+y (没溢出)
    - x+y=x+y+2^w (负溢出)
- 补数的非 : -TMIN=TMIN , 其他 : 求补+1 或者 求反直到遇到最后一个1为止(最后一个保留)

```c++
// 补数相加溢出判断
int tadd_ok(int x, int y){
	int t=x+y;
	return !(x>0 && y>0 && t<0) && !(x<0 && y<0 && t>=0); 
}
// 补数相减溢出判断
int tsub_ok(int x, int y){
	if(y==INT_MIN) return x<0 ? 0 : 1;
	return tadd_ok(x, -y);
}
```

### 无符号和补码乘法
- 无符号乘法和补码乘法有位级等价性
    - T2Bw( x \* y ) = U2Bw( T2Uw(x) \* T2Uw(y) ) = U2Bw( (x\*y) mod 2^w )
    - x \* y = U2T( (x\*y) mod 2^w )

```c
// 判断补码乘法是否溢出
int tmul_ok(int x, int y){
	int t=x*y;
	return !x || t/x==y;
}
// 或者对比 用双倍大小存放正确结果 与 拓展计算结果 对比是否相等
int tmul_ok_64(int32_t x, int32_t y){
    int64_t t1= ((int64_t)x) * ((int64_t)y);
    int32_t t2= x*y;
    return int32_t(t1)==t2;
}
```

- 无符号数 \* 2^k 等价 <\<k , 补码同理
- 乘以常数K(0111110) 有两种转换方法 :  
    - 位权相加 : K=2^k1+2^k2+...+2^kn 
    - 连续1转换为两个位权相减 : K=2^6-2^1

### 无符号与补码除法
- 一般规定整数除法向零取整 ( 整数向下取整 , 负数向上取整 )
- 无符号数/2^k 等价 >\>k , 向下取整
- 补码/2^k 等价 >\>k : 
    - 正数向下取整
    - 负数也向下取整, 为了做出调整得做调整
- 负数补码整除调整 : 
    - 偏置法每次向左移动移位, 舍掉1 末位+1 , 舍掉0 末位+0
    - \>\>k == (x+2^k-1) / 2^k 原理 上取整(x/y) = 下取整( (x+y-1)/y )
```c
int div16(int x){
	// return x>0?x>>4? (x+(1<<4-1))>>4;
    return x+(x>>31&0xF)>>4;
}
```

### 浮点数
